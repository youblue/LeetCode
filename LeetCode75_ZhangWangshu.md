# LeetCode75
* 作者：张望舒
* 版本：2018-02-14

# 题⽬描述 Sort Colors
* Input: int[] nums
* Output: void

# 思路报告
1. 题目的背景是红白蓝颜色排序，目的主要是形象化一点，并且暗示待排序的事物是finite categorical的。我们需要把问题抽象成为将一组只由0，1，2组成的数排序。
2. 注意这里只有三种颜色！所以一个想法遍历数组，边遍历边排序。

    * 在遍历的过程中如果当前元素是0，那就和当前元素i左手边第一个非0的元素作交换（如果左手边全是0不影响结果，每次都选择新的0交换）。因为前i-1个元素数是已经排好序的了，那么交换后前i个元素就是符合要求排好序的（可以从前2个元素开始由数学归纳法证明）。
    * 同理如果当前元素i的值是2，那就和i右手边最后一个非2元素来换（全是2也不影响结果，每次也都选择新的2交换）。这样只能保证最后一个非2元素以及所有之后的元素的顺序是正确的，但是不能保证交换后第i个数就被正确放置了。所以说第i个数仍然要和交换后的最后一个非2元素再比较一次！
3. 为了记录左手边第一个非0元素和右手边最后一个非2元素的位置（并且要能移动），于是想到了用相遇型双指针。Follow步骤2的想法，左右指针分别指向数组首末两端。如果当前是元素i的值是0，那么和left指针指向的元素交换和left指针++即可，接下来i++（前i个元素处理完毕）。如果当前元素i的值是2，那么和right指针指向的元素交换，right指针- -，但是i需要原地踏步（因为不能保证换过来的元素被排在正确的位置上，如果是2那它需要再和右边的交换，如果是0那它需要再和左边的交换，所以需要再观察一次！）。
4. 难点就是指针移动的终止条件！因为上面已经分析了如果当前元素是i，那么前i-1个元素应该是已经排好序的，right指针指向位置右边的元素也是排好序的，那么就是i和right之间的元素是未排序的，所以终止条件就是i > right。


### 代码

```Java
// Java
class Solution {
    public void sortColors(int[] nums) {
        if(nums == null || nums.length <= 1) {
            return;
        }
        int left = 0, right = nums.length - 1;
        for(int i = 0; i <= right; i++) {
            if(nums[i] == 0) {
                swap(nums, i, left);
                left++;
            } else if(nums[i] == 2) {
                swap(nums, i, right);
                right--;
                i--;
            }
        }
        return;
    }
    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

# 套路总结

* 练习双指针问题的指针移动停止条件，多多列举test cases。
* swap函数可以作为一个模块记下来，在其他相似的问题中也可以使用。
* 这个题目可以先问清楚是不是可以用extra space，如果可以用的话可能直接用count sort比指针操作更不容易出错。
